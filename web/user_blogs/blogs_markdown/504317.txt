##### 资料:归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
![](https://img-blog.csdnimg.cn/20200120203553730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODM5NzA4,size_16,color_FFFFFF,t_70)
由图绿色部分可以看出，归并排序是将两个有序的数组合并成一个，如此往复，直到合并成总数组。

那么如何得到有序的两个数组呢？接下来为你解答。
**分治分治，先分后治**

###### 分:
将序列分成足够小的几份;
如:  {2，11，10，5，4，13，9，7，8，1，12，3，6，15，14}
分成 :
 1. {2}，{11}
 2. {10}，{5}
 3. {4}，{13}
 4. {9}，{7}
 5. {8}，{1}
 6. {12}，{3}
 7. {6}，{15}
 8. {14}
*如上过程，将数组不断分不断分，最终分成只含有一个元素的数组不就是有序的数组了吗？*
###### 治:
*然后将有序的数组一个一个合并(降序升序自定，此处为升序)，最终合并成总数组。*
 1. {2}，{11} ――> {11，2} h{10}，{5} ――> {5，10}h{4}，{13} ――> {4，13}h{9}，{7} ――> {7，9}h{8}，{1} ――> {1，8}h{12}，{3} ――> {3，12}h{6}，{15} ――> {15，6}h{14} ――> {14}
 
 2. {2，5，10，11}  {4，7，9，13}  {1，3，8，12}  {6，14，15}
 
 3. {2，4，5，7，9，10，11，13}  {1，3，6，8，12，14，15}
 
 4. {1，2，3，4，5，6，7，8，9，10，11，12，13，14，15}

总流程如图所示:
![](https://img-blog.csdnimg.cn/20200120203507642.gif)

代码如下:
```c
#include<stdio.h>

void Merge(int a[], int b[], int start, int mid, int end)
{
    int i = start, j = mid+1, k = start;
    while(i < mid+1 && j < end+1)
    {
        if(a[i] <= a[j])
            b[k++] = a[i++];
        else
            b[k++] = a[j++];
    }
    //  此步执行完成，总会有未全部存完的部分
    while(i!=mid+1)  //  假如左半部分未全部存完
         b[k++] = a[i++];
    while(j!=end+1)  //  假如右半部分未全部存完
         b[k++] = a[j++];
    for(i = start; i < end+1; i++)  // 将已经排序好的有序序列  重新赋回原数组  此为下一步归并的基础
        a[i] = b[i];
}
void Merge_sort(int a[], int b[], int start, int end)
{
    if(start >= end) return;
    
    int mid = start + (end - start)/2;  // 每次都从中间位置分成两份
    
    Merge_sort(a,b,start,mid);  //  左半部分继续分
    Merge_sort(a,b,mid+1,end);  //  右半部分继续分
    Merge(a,b,start,mid,end);  //  直到不能再分了，进行归并
}
int main()
{
    int a[] = {2,11,10,5,4,13,9,7,8,1,12,3,6,15,14};
    int b[15]={0};  //  定义中间数组用来归并
    int i;
    
    Merge_sort(a,b,0,14);
    for(i = 0; i < 15; i++)
        printf("%d ",a[i]);
        
    return 0;
}
```
**归并排序为稳定排序(稳定排序:  假如 ai == aj&&i＜j ，经过排序后，ai依旧在aj前面)**
**时间复杂度为: O(n logn)**


归并排序一般用来求逆序数
**逆序数**: 在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。一个排列中所有逆序总数叫做这个排列的逆序数。也就是说，对于n个不同的元素，先规定各元素之间有一个标准次序（例如n个 不同的自然数，可规定从小到大为标准次序），于是在这n个元素的任一排列中，当某两个元素的先后次序与标准次序不同时，就说有1个逆序。一个排列中所有逆序总数叫做这个排列的逆序数。(来自百度)

如:  5 6 3 4 2 的逆序数为 3+3+1+1＝8
(5大于 3，4，2 逆序数为 3; 6大于3，4，2 逆序数为 3; 3大于2 逆序数为 1; 四大于2逆序数为 1)


**又例如两个有序的数组需要归并，并求逆序数**

{4，7，9，12} 与 {3，5，8，13}
左边数组开始的 4 大于 右边数组开始的 3 。又因为都是有序的数组，所以左边数组 4 接下来是升序的并且都会比 3 大。所以逆序数数值加 4 以此类推求出总的逆序数。

所以由此可以知道只要在归并操作里简单加一笔。
如下:

```c
    while(i < mid+1 && j < end+1)
    {
        if(a[i] <= a[j])
            b[k++] = a[i++];
        else
        {
            b[k++] = a[j++];
            sum+= mid - i + 1; // 此处为加的那一笔
        }  
    }
```
求逆序数还可以用简单暴力的方法，大家也都想得到，但时间复杂度为O(n*n)，效率低只适合数组长度较小的题。

还有树状数组求解，本人学艺不精，等学会后马上写博客